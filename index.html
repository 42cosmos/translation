<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Hoanh An" />
  <title>The Ultimate Go Study Guide</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Ultimate Go Study Guide</h1>
<p class="author">Hoanh An</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction-5">Introduction 5</a></li>
<li><a href="#language-mechanics-6">Language Mechanics 6</a>
<ul>
<li><a href="#syntax-6">Syntax 6</a>
<ul>
<li><a href="#variable-6">Variable 6</a></li>
<li><a href="#struct-8">Struct 8</a></li>
<li><a href="#pointer-11">Pointer 11</a></li>
<li><a href="#escape-analysis-12">Escape analysis 12</a></li>
<li><a href="#function-15">Function 15</a></li>
<li><a href="#constant-17">Constant 17</a></li>
</ul></li>
<li><a href="#data-structures">Data Structures</a>
<ul>
<li><a href="#array">Array</a></li>
<li><a href="#slice">Slice</a></li>
<li><a href="#map">Map</a></li>
</ul></li>
<li><a href="#decoupling">Decoupling</a>
<ul>
<li><a href="#method">Method</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#embedding-55">Embedding 55</a></li>
<li><a href="#exporting-60">Exporting 60</a></li>
</ul></li>
</ul></li>
<li><a href="#software-design-65">Software Design 65</a>
<ul>
<li><a href="#composition-65">Composition 65</a>
<ul>
<li><a href="#grouping-types-65">Grouping types 65</a></li>
<li><a href="#decoupling-70">Decoupling 70</a></li>
<li><a href="#conversion">Conversion</a></li>
<li><a href="#interface-pollution">Interface Pollution</a></li>
<li><a href="#mocking">Mocking</a></li>
</ul></li>
<li><a href="#error-handling">Error Handling</a>
<ul>
<li><a href="#default-error-values">Default error values</a></li>
<li><a href="#error-variables">Error variables</a></li>
<li><a href="#type-as-context">Type as context</a></li>
<li><a href="#behavior-as-context">Behavior as context</a></li>
<li><a href="#finding-the-bug">Finding the bug</a></li>
<li><a href="#wrapping-errors">Wrapping Errors</a></li>
</ul></li>
</ul></li>
<li><a href="#concurrency-114">Concurrency 114</a>
<ul>
<li><a href="#mechanics-114">Mechanics 114</a>
<ul>
<li><a href="#goroutine-114">Goroutine 114</a></li>
<li><a href="#language-mechanics-121">Language Mechanics 121</a></li>
<li><a href="#data-race-128">Data race 128</a></li>
<li><a href="#channel-139">Channel 139</a></li>
</ul></li>
<li><a href="#patterns-164">Patterns 164</a>
<ul>
<li><a href="#context-164">Context 164</a></li>
</ul></li>
</ul></li>
<li><a href="#testing-and-profiling-173">Testing and Profiling 173</a>
<ul>
<li><a href="#testing-173">Testing 173</a>
<ul>
<li><a href="#basic-unit-test-173">Basic Unit Test 173</a></li>
</ul></li>
<li><a href="#benchmarking-191">Benchmarking 191</a>
<ul>
<li><a href="#basic-benchmark-191">Basic Benchmark 191</a></li>
<li><a href="#sub-benchmark-192">Sub Benchmark 192</a></li>
</ul></li>
<li><a href="#profiling-193">Profiling 193</a>
<ul>
<li><a href="#stack-trace-193">Stack Trace 193</a></li>
<li><a href="#godebug-196">GODEBUG 196</a></li>
</ul></li>
</ul></li>
<li><a href="#keep-in-touch-199">Keep in touch 199</a></li>
</ul>
</nav>
<h2 id="introduction-5">Introduction 5</h2>
<h2 id="language-mechanics-6">Language Mechanics 6</h2>
<h3 id="syntax-6">Syntax 6</h3>
<h4 id="variable-6">Variable 6</h4>
<h5 id="built-in-types-6">Built-in types 6</h5>
<h5 id="zero-value-concept-6">Zero value concept 6</h5>
<h5 id="declare-and-initialize-7">Declare and initialize 7</h5>
<h5 id="conversion-vs-casting-8">Conversion vs casting 8</h5>
<h4 id="struct-8">Struct 8</h4>
<h5 id="declare-and-initialize-8">Declare and initialize 8</h5>
<h5 id="name-type-vs-anonymous-type-10">Name type vs anonymous type 10</h5>
<h4 id="pointer-11">Pointer 11</h4>
<h5 id="everything-is-about-pass-by-value-11">Everything is about pass by value 11</h5>
<h5 id="pass-by-value-11">Pass by value 11</h5>
<h4 id="escape-analysis-12">Escape analysis 12</h4>
<h4 id="function-15">Function 15</h4>
<h4 id="constant-17">Constant 17</h4>
<h5 id="declare-and-initialize-17">Declare and initialize 17</h5>
<h5 id="iota-19">iota 19</h5>
<h3 id="data-structures">Data Structures</h3>
<h4 id="array">Array</h4>
<h5 id="cpu-cache">CPU Cache</h5>
<p>Cores DO NOT access main memory directly but their local caches. What store in caches are data and instruction.</p>
<p>Cache speed from fastest to slowest: L1 -&gt; L2 -&gt; L3 -&gt; main memory. As Scott Meyers has said “If performance matters then the total memory you have is the total amount of caches”. Access to main memory is incredibly slow. Practically speaking it might not even be there.</p>
<p>So how do we write code that can be sympathetic with the caching system to make sure that we don’t have a cache miss or at least, we minimize cache misses to our fullest potential?</p>
<p>Processor has a Prefetcher. It predicts what data is needed ahead of time. There are different granularities depending on where we are on the machine. Our programming model uses a byte. We can read and write to a byte at a time. However, from the caching system point of view, our granularity is not 1 byte. It is 64 bytes, called a cache line. All memory us junked up in this 64 bytes cache line. Since the caching mechanism is complex, Prefetcher tries to hide all the latency from us. It has to be able to pick up on predictable access patterns to data. That said, we need to write code that creates predictable access patterns to data.</p>
<p>One easy way is to create a contiguous allocation of memory and to iterate over them. The array data structure gives us the ability to do so. From the hardware perspective, array is the most important data structure. From Go perspective, slice is. Array is the backing data structure for slice (like Vector in C++). Once we allocate an array, whatever its size, every element is equally distant from other elements. As we iterate over that array, we begin to walk cache line by cache line. As the Prefetcher sees that access pattern, it can pick it up and hide all the latency from us.</p>
<p>For example, we have a big nxn matrix. We do LinkedList Traverse, Column Traverse, and Row Traverse and benchmark against them. Unsurprisingly, Row Traverse has the best performance. It walks through the matrix cache line by cache line and creates a predictable access pattern. Column Traverse does not walk through the matrix cache line by cache line. It looks like a random access memory pattern. That is why it is the slowest among those. However, that doesn’t explain why LinkedList Traverse’s performance is in the middle. We just think that it might perform as poorly as the Column Traverse. This leads us to another cache: TLB - Translation Lookaside Buffer. Its job is to maintain the operating system’s page and offset to where physical memory is.</p>
<h5 id="translation-lookaside-buffer">Translation Lookaside Buffer</h5>
<p>Back to the different granularity, the caching system moves data in and out the hardware at 64 bytes at a time. However, the operating system manages memory by paging its 4K (traditional page size for an operating system).</p>
<p>For every page that we are managing, let’s take our virtual memory addresses because that we use (softwares runs virtual addresses, its sandbox, that is how we use/share physical memory) and map it to the right page and offset for that physical memory.</p>
<p>A miss on the TLB can be worse than just the cache miss alone. The LinkedList is somewhere in between because the chance of multiple nodes being on the same page is probably pretty good. Even though we can get cache misses because cache lines aren’t necessary in the distance that is predictable, we probably do not have so many TLB cache misses. In the Column Traverse, not only do we have cache misses, we probably have a TLB cache miss on every access as well.</p>
<p>That said, data-oriented design matters. It is not enough to write the most efficient algorithm, how we access our data can have much more lasting effect on the performance than the algorithm itself.</p>
<h5 id="declare-and-initialize">Declare and initialize</h5>
<p>Declare an array of five strings that is initialized to its zero value. To recap, a string is a 2 word data structure: a pointer and a length. Since this array is set to its zero value, every string in this array is also set to its zero value, which means that each string has the first word pointed to nil and the second word is 0.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">var</span> strings [<span class="dv">5</span>]<span class="dt">string</span></span></code></pre></div>
<p>At index 0, a string now has a pointer to a backing array of bytes (characters in string) and its length is 5.</p>
<h5 id="what-is-the-cost">What is the cost?</h5>
<p>The cost of this assignment is the cost of copying 2 bytes. We have two string values that have pointers to the same backing array of bytes. Therefore, the cost of this assignment is just 2 words.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>strings[<span class="dv">0</span>] = <span class="st">&quot;Apple&quot;</span></span></code></pre></div>
<p>Similarly, assign more values to the rest of the slice.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>strings[<span class="dv">1</span>] = <span class="st">&quot;Orange&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>strings[<span class="dv">2</span>] = <span class="st">&quot;Banana&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>strings[<span class="dv">3</span>] = <span class="st">&quot;Grape&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>strings[<span class="dv">4</span>] = <span class="st">&quot;Plum&quot;</span></span></code></pre></div>
<h5 id="iterate-over-the-array-of-strings">Iterate over the array of strings</h5>
<p>Using range, not only we can get the index but also a copy of the value in the array. fruit is now a string value; its scope is within the for statement. In the first iteration, we have the word “Apple”. It is a string that has the first word also points to (1) and the second word is 5. So we now have 3 different string values all sharing the same backing array.</p>
<p><strong>What are we passing to the Println function?</strong></p>
<p>We are using value semantics here. We are not sharing our string value. Println is getting its own copy, its own string value. It means when we get to the Println call, there are now 4 string values all sharing the same backing array. We don’t want to take the address of a string. We know the size of a string ahead of time. That means it has the ability to be on the stack because it is not creating allocation and also not causing pressure on the GC. The string has been designed to leverage value mechanics, to stay on the stack, out of the way of creating garbage. Hence, the only thing that has to be on the heap, if anything is the backing array, which is the one thing that being shared</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Iterate over array</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">for</span> i, fruit := <span class="kw">range</span> strings {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    fmt.Println(i, fruit)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Iterate over array
0 Apple
1 Orange
2 Banana
3 Grape
4 Plum</code></pre>
<p>Declare an array of 4 integers that is initialized with some values using literal syntax.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>numbers := [<span class="dv">4</span>]<span class="dt">int</span>{<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>}</span></code></pre></div>
<p>Iterate over the array of numbers using traditional style.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Iterate over array using traditional style</span><span class="ch">\n</span><span class="st">&quot;</span>​)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">for</span> i := <span class="dv">0</span>;i &lt; <span class="bu">len</span>(numbers);i++ {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    fmt.Println(i, numbers[i])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Iterate over array using traditional style
0 10
1 20
2 30
3 40</code></pre>
<h5 id="different-type-arrays">Different type arrays</h5>
<p>Declare an array of 5 integers that is initialized to its zero value.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">var</span> five [<span class="dv">5</span>]<span class="dt">int</span></span></code></pre></div>
<p>Declare an array of 4 integers that is initialized with some values.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>four := [<span class="dv">4</span>]<span class="dt">int</span>{<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>}</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Different type arrays</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>fmt.Println(five)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>fmt.Println(four)</span></code></pre></div>
<pre><code>=&gt; Different type arrays
[0 0 0 0 0]
[10 20 30 40]</code></pre>
<p>When we try to assign four to five like so five = four, the compiler says that “cannot use four (type [4]int) as type [5]int in assignment”. This cannot happen because they have different types (size and representation). The size of an array makes up its type name: [4]int vs [5]int. Just like what we’ve seen with pointers. The * in *int is not an operator but part of the type name. Unsurprisingly, all arrays have known size at compile time.</p>
<h5 id="contiguous-memory-allocations">Contiguous memory allocations</h5>
<p>Declare an array of 6 strings initialized with values.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>six := [<span class="dv">6</span>]<span class="dt">string</span>{<span class="st">&quot;Annie&quot;</span>, <span class="st">&quot;Betty&quot;</span>, <span class="st">&quot;Charley&quot;</span>, <span class="st">&quot;Doug&quot;</span>, <span class="st">&quot;Edward&quot;</span>, <span class="st">&quot;Hoanh&quot;</span>}</span></code></pre></div>
<p>Iterate over the array displaying the value and address of each element. By looking at the output of this Printf function, we can see that this array is truly a contiguous block of memory. We know a string is 2 words and depending on computer architecture, it will have x byte. The distance between two consecutive IndexAddr is exactly x byte. v is its own variable on the stack and it has the same address every single time.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">for</span> i, v := <span class="kw">range</span> six {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    fmt.Printf(<span class="st">&quot;Value[%s]</span><span class="ch">\t</span><span class="st">Address[%p] IndexAddr[%p]</span><span class="ch">\n</span><span class="st">&quot;</span>, v, &amp;v, &amp;six[i])</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Contiguous memory allocations
Value[Annie] Address[0xc000010250] IndexAddr[0xc000052180]
Value[Betty] Address[0xc000010250] IndexAddr[0xc000052190]
Value[Charley] Address[0xc000010250] IndexAddr[0xc0000521a0]
Value[Doug] Address[0xc000010250] IndexAddr[0xc0000521b0]
Value[Edward] Address[0xc000010250] IndexAddr[0xc0000521c0]
Value[Hoanh] Address[0xc000010250] IndexAddr[0xc0000521d0]</code></pre>
<h4 id="slice">Slice</h4>
<h5 id="declare-and-initialize-1">Declare and initialize</h5>
<p>Create a slice with a length of 5 elements. make is a special built-in function that only works with slice, map and channel. make creates a slice that has an array of 5 strings behind it. We are getting back a 3 word data structure: the first word points to the backing array, second word is length and third one is capacity.</p>
<h5 id="length-vs-capacity">Length vs Capacity</h5>
<p>Length is the number of elements from this pointer position we have access to (read and write). Capacity is the total number of elements from this pointer position that exist in the backing array.</p>
<p>Because it uses syntactic sugar, it looks just like an array. It also has the same cost that we’ve seen in array. However, there’s one thing to be mindful about: there is no value in the bracket []string inside the make function. With that in mind, we can constantly notice that we are dealing with a slice, not array.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>slice1 := <span class="bu">make</span>([]<span class="dt">string</span>, <span class="dv">5</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>slice1[<span class="dv">0</span>] = <span class="st">&quot;Apple&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>slice1[<span class="dv">1</span>] = <span class="st">&quot;Orange&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>slice1[<span class="dv">2</span>] = <span class="st">&quot;Banana&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>slice1[<span class="dv">3</span>] = <span class="st">&quot;Grape&quot;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>slice1[<span class="dv">4</span>] = <span class="st">&quot;Plum&quot;</span></span></code></pre></div>
<p>We can’t access an index of a slice beyond its length.</p>
<pre><code>Error: panic: runtime error: index out of range slice1[5] = &quot;Runtime error&quot;</code></pre>
<p>We are passing the value of slice, not its address. So the Println function will have its own copy of the slice.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Printing a slice</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>fmt.Println(slice1)</span></code></pre></div>
<pre><code>=&gt; Printing a slice
[Apple Orange Banana Grape Plum]</code></pre>
<h5 id="reference-type">Reference type</h5>
<p>To create a slice with a length of 5 elements and a capacity of 8, we can use the keyword ​<em>make</em>​. <em>make</em> allows us to adjust the capacity directly on construction of this initialization.</p>
<p>What we end up having now is a 3 word data structure where the first word points to an array of 8 elements, length is 5 and capacity is 8. It means that I can read and write to the first 5 elements and I have 3 elements of capacity that I can leverage later.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>slice2 := <span class="bu">make</span>([]<span class="dt">string</span>, <span class="dv">5</span>, <span class="dv">8</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>slice2[<span class="dv">0</span>] = <span class="st">&quot;Apple&quot;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>slice2[<span class="dv">1</span>] = <span class="st">&quot;Orange&quot;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>slice2[<span class="dv">2</span>] = <span class="st">&quot;Banana&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>slice2[<span class="dv">3</span>] = <span class="st">&quot;Grape&quot;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>slice2[<span class="dv">4</span>] = <span class="st">&quot;Plum&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Length vs Capacity</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>inspectSlice(slice2)</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">// inspectSlice exposes the slice header for review.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="co">// Parameter: again, there is no value in side the []string so we want a slice.</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="co">// Range over a slice, just like we did with array.</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="co">// While len tells us the length, cap tells us the capacity</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="co">// In the output, we can see the addresses are aligning as expected.</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span class="kw">func</span> inspectSlice(slice []<span class="dt">string</span>) {</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    fmt.Printf(<span class="st">&quot;Length[%d] Capacity[%d]</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="bu">len</span>(slice), <span class="bu">cap</span>(slice))</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="kw">for</span> i := <span class="kw">range</span> slice {</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>        fmt.Printf(<span class="st">&quot;[%d] %p %s</span><span class="ch">\n</span><span class="st">&quot;</span>, i, &amp;slice[i], slice[i])</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>    }</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Length vs Capacity
Length[5] Capacity[8]
[0] 0xc00007e000 Apple
[1] 0xc00007e010 Orange
[2] 0xc00007e020 Banana
[3] 0xc00007e030 Grape
[4] 0xc00007e040 Plum</code></pre>
<h5 id="idea-of-appending-making-slice-a-dynamic-data-structure">Idea of appending: making slice a dynamic data structure</h5>
<p>Declare a nil slice of strings, set to its zero value. 3 word data structure:</p>
<p>first one points to nil, second and last are zero.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">var</span> data []<span class="dt">string</span></span></code></pre></div>
<p>What if I do data := string{}? Is it the same?</p>
<p>No, because data in this case is not set to its zero value. This is why we always use var for zero value because not every type when we create an empty literal we have its zero value in return. What actually happens here is that we have a slice but it has a pointer (as opposed to nil). This is considered an empty slice, not a nil slice. There is a semantic between a nil slice and an empty slice. Any reference type that is set to its zero value can be considered nil. If we pass a nil slice to a marshal function, we get back a string that says null but when we pass an empty slice, we get an empty JSON document. But where does that pointer point to? It is an empty struct, which we will review later.</p>
<p>Capture the capacity of the slice.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>    lastCap := <span class="bu">cap</span>(data)</span></code></pre></div>
<p>Append ~100k strings to the slice.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>    <span class="kw">for</span> record := <span class="dv">1</span>;record &lt;= <span class="dv">102400</span>;record++ {</span></code></pre></div>
<p>Use the built-in function append to add to the slice. It allows us to add value to a slice, making the data structure dynamic, yet still allows us to use that contiguous block of memory that gives us the predictable access pattern from mechanical sympathy. The append call is working with value semantic. We are not sharing this slice but appending to it and returning a new copy of it. The slice gets to stay on the stack, not heap.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>    data = <span class="bu">append</span>(data, fmt.Sprintf(<span class="st">&quot;Rec: %d&quot;</span>, record))</span></code></pre></div>
<p>Every time append runs, it checks the length and capacity. If it is the same, it means that we have no room. append creates a new backing array, double its size, copy the old value back in and append the new value. It mutates its copy on its stack frame and returns us a copy. We replace our slice with the new copy. If it is not the same, it means that we have extra elements of capacity we can use. Now we can bring these extra capacities into the length and no copy is being made. This is very efficient. Looking at the last column in the output, when the backing array is 1000 elements or less, it doubles the size of the backing array for growth. Once we pass 1000 elements, the growth rate moves to 25%. When the capacity of the slice changes, display the changes.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>    <span class="kw">if</span> lastCap != <span class="bu">cap</span>(data) {</span></code></pre></div>
<p>Calculate the percent of change.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>    capChg := <span class="dt">float64</span>(<span class="bu">cap</span>(data)-lastCap) / <span class="dt">float64</span>(lastCap) * 100 </span></code></pre></div>
<p>Save the new values for capacity.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>    lastCap = <span class="bu">cap</span>(data)</span></code></pre></div>
<p>Display the results.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>    fmt.Printf(<span class="st">&quot;Addr[%p]</span><span class="ch">\t</span><span class="st">Index[%d]</span><span class="ch">\t\t</span><span class="st">Cap[%d - %2.f%%]</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;data[<span class="dv">0</span>], record, <span class="bu">cap</span>(data), capChg)</span></code></pre></div>
<pre><code>=&gt; Idea of appending
Addr[0xc0000102a0] Index[1] Cap[1 - +Inf%]
Addr[0xc00000c0c0] Index[2] Cap[2 - 100%]
Addr[0xc000016080] Index[3] Cap[4 - 100%]
Addr[0xc00007e080] Index[5] Cap[8 - 100%]
Addr[0xc000100000] Index[9] Cap[16 - 100%]
Addr[0xc000102000] Index[17] Cap[32 - 100%]
Addr[0xc00007a400] Index[33] Cap[64 - 100%]
Addr[0xc000104000] Index[65] Cap[128 - 100%]
Addr[0xc000073000] Index[129] Cap[256 - 100%]
Addr[0xc000106000] Index[257] Cap[512 - 100%]
Addr[0xc00010a000] Index[513] Cap[1024 - 100%]
Addr[0xc000110000] Index[1025] Cap[1280 - 25%]
Addr[0xc00011a000] Index[1281] Cap[1704 - 33%]
Addr[0xc000132000] Index[1705] Cap[2560 - 50%]
Addr[0xc000140000] Index[2561] Cap[3584 - 40%]
Addr[0xc000154000] Index[3585] Cap[4608 - 29%]
Addr[0xc000180000] Index[4609] Cap[6144 - 33%]
Addr[0xc000198000] Index[6145] Cap[7680 - 25%]
Addr[0xc0001b6000] Index[7681] Cap[9728 - 27%]
Addr[0xc000200000] Index[9729] Cap[12288 - 26%]
Addr[0xc000230000] Index[12289] Cap[15360 - 25%]
Addr[0xc000280000] Index[15361] Cap[19456 - 27%]
Addr[0xc000300000] Index[19457] Cap[24576 - 26%]
Addr[0xc000360000] Index[24577] Cap[30720 - 25%]
Addr[0xc000400000] Index[30721] Cap[38400 - 25%]
Addr[0xc000300000] Index[38401] Cap[48128 - 25%]
Addr[0xc000600000] Index[48129] Cap[60416 - 26%]
Addr[0xc0006ec000] Index[60417] Cap[75776 - 25%]
Addr[0xc000814000] Index[75777] Cap[94720 - 25%]
Addr[0xc000600000] Index[94721] Cap[118784 - 25%]</code></pre>
<h5 id="slice-of-slice">Slice of slice</h5>
<p>Take a slice of slice2. We want just indexes 2 and 3. The length is slice3 is 2 and capacity is 6.</p>
<p>Parameters are [starting_index:(starting_index + length)]</p>
<p>By looking at the output, we can see that they are sharing the same backing array. These slice headers get to stay on the stack when we use these value semantics. Only the backing array that needed to be on the heap.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>slice3 := slice2[<span class="dv">2</span>:<span class="dv">4</span>]</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Slice of slice (before)</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>inspectSlice(slice2)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>inspectSlice(slice3)</span></code></pre></div>
<p>When we change the value of the index 0 of slice3, who are going to see this change?</p>
<pre><code>=&gt; Slice of slice (before)
Length[5] Capacity[8]
[0] 0xc00007e000 Apple
[1] 0xc00007e010 Orange
[2] 0xc00007e020 Banana
[3] 0xc00007e030 Grape
[4] 0xc00007e040 Plum
Length[2] Capacity[6]
[0] 0xc00007e020 Banana
[1] 0xc00007e030 Grape</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>slice3[<span class="dv">0</span>] = <span class="st">&quot;CHANGED&quot;</span></span></code></pre></div>
<p>The answer is both. We have to always be aware that we are modifying an existing slice. We have to be aware who is using it, who is sharing that backing array.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Slice of slice (after)</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>inspectSlice(slice2)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>inspectSlice(slice3)</span></code></pre></div>
<pre><code>=&gt; Slice of slice (after)
Length[5] Capacity[8]
[0] 0xc00007e000 Apple
[1] 0xc00007e010 Orange
[2] 0xc00007e020 CHANGED
[3] 0xc00007e030 Grape
[4] 0xc00007e040 Plum
Length[2] Capacity[6]
[0] 0xc00007e020 CHANGED
[1] 0xc00007e030 Grape</code></pre>
<p>How about slice3 := append(slice3, “CHANGED”)? Similar problem will occur with append if the length and capacity is not the same. Instead of changing slice3 at index 0, we call append on slice3. Since the length of slice3 is 2, capacity is 6 at the moment, we have extra rooms for modification. We go and change the element at index 3 of slice3, which is index 4 of slice2. That is very dangerous. So, what if the length and capacity is the same? Instead of making slice3 capacity 6, we set it to 2 by adding another parameter to the slicing syntax like this: slice3 := slice2[2:4:4]</p>
<p>When append looks at this slice and sees that the length and capacity is the same, it wouldn’t bring in the element at index 4 of slice2. It would detach. slice3 will have a length of 2 and capacity of 2, still share the same backing array. On the call to append, length and capacity will be different. The addresses are also different. This is called a 3 index slice. This new slice will get its own backing array and we don’t affect anything at all to our original slice.</p>
<h5 id="copy-a-slice">Copy a slice</h5>
<p>copy only works with string and slice only. Make a new slice big enough to hold elements of the original slice and copy the values over using the built-in copy function.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>slice4 := <span class="bu">make</span>([]<span class="dt">string</span>, <span class="bu">len</span>(slice2))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a><span class="bu">copy</span>(slice4, slice2)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Copy a slice</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>inspectSlice(slice4)</span></code></pre></div>
<pre><code>=&gt; Copy a slice
Length[5] Capacity[5]
[0] 0xc00005c050 Apple
[1] 0xc00005c060 Orange
[2] 0xc00005c070 CHANGED
[3] 0xc00005c080 Grape
[4] 0xc00005c090 Plum</code></pre>
<h5 id="slice-and-reference">Slice and reference</h5>
<p>Declare a slice of integers with 7 values.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>x := <span class="bu">make</span>([]<span class="dt">int</span>, <span class="dv">7</span>)</span></code></pre></div>
<p>Random starting counters.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">7</span>; i++ {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>    x[i] = i * <span class="dv">100</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Set a pointer to the second element of the slice.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>twohundred := &amp;x[<span class="dv">1</span>]</span></code></pre></div>
<p>Append a new value to the slice. This line of code raises a red flag. We have x is a slice with length 7, capacity 7. Since the length and capacity is the same, append doubles its size then copy values over. x nows points to different memory block and has a length of 8, capacity of 14.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>x = <span class="bu">append</span>(x, <span class="dv">800</span>)</span></code></pre></div>
<p>When we change the value of the second element of the slice, twohundred is not gonna change because it points to the old slice. Everytime we read it, we will get the wrong value.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>x[<span class="dv">1</span>]++</span></code></pre></div>
<p>By printing out the output, we can see that we are in trouble.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Slice and reference</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>fmt.Println(<span class="st">&quot;twohundred:&quot;</span>, *twohundred, <span class="st">&quot;x[1]:&quot;</span>, x[<span class="dv">1</span>])</span></code></pre></div>
<pre><code>=&gt; Slice and reference
twohundred: 100 x[1]: 101</code></pre>
<h5 id="utf-8">UTF-8</h5>
<p>Everything in Go is based on UTF-8 character sets. If we use different encoding scheme, we might have a problem.</p>
<p>Declare a string with both Chinese and English characters. For each Chinese character, we need 3 byte for each one. The UTF-8 is built on 3 layers: bytes, code point and character. From Go perspective, string are just bytes. That is what we are storing.</p>
<p>In our example, the first 3 bytes represents a single code point that represents that single character. We can have anywhere from 1 to 4 bytes representing a code point (a code point is a 32 bit value) and anywhere from 1 to multiple code points can actually represent a character. To keep it simple, we only have 3 bytes representing 1 code point representing 1 character. So we can read s as 3 bytes, 3 bytes, 1 byte, 1 byte,… (since there are only 2 Chinese characters in the first place, the rest are English)</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>s := <span class="st">&quot;世界 means world&quot;</span></span></code></pre></div>
<p>UTFMax is 4 – up to 4 bytes per encoded rune -&gt; maximum number of bytes we need to represent any code point is 4. mRune is its own type. It is an alias for int32 type. Similar to type byte we are using, it is just an alias for uint8.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">var</span> buf [utf8.UTFMax]<span class="dt">byte</span></span></code></pre></div>
<p>When we are ranging over a string, are we doing it byte by byte or code point by code point or character by character? The answer is code point by code point. On the first iteration, i is 0. On the next one, i is 3 because we are moving to the next code point. Then i is 6.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">for</span> i, r := <span class="kw">range</span> s {</span></code></pre></div>
<p>Capture the number of bytes for this rune/code point.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>    rl := utf8.RuneLen(r)</span></code></pre></div>
<p>Calculate the slice offset for the bytes associated with this rune.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>    si := i + rl</span></code></pre></div>
<p>Copy rune from the string to our buffer. We want to go through every code point and copy them into our array buf, and display them on the screen. “Every array is just a slice waiting to happen.” - Go saying We are using the slicing syntax, creating our slice header where buf becomes the backing array. All of them are on the stack. There is no allocation here.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>    <span class="bu">copy</span>(buf[:], s[i:si])</span></code></pre></div>
<p>Display the details.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>    fmt.Printf(<span class="st">&quot;%2d: %q; codepoint: %#6x; encoded bytes: %#v</span><span class="ch">\n</span><span class="st">&quot;</span>​, i, r, r, buf[:rl])</span></code></pre></div>
<pre><code>0: &#39;世&#39;; codepoint: 0x4e16; encoded bytes: []byte{0xe4, 0xb8, 0x96}
3: &#39;界&#39;; codepoint: 0x754c; encoded bytes: []byte{0xe7, 0x95, 0x8c}
6: &#39; &#39;; codepoint: 0x20; encoded bytes: []byte{0x20}
7: &#39;m&#39;; codepoint: 0x6d; encoded bytes: []byte{0x6d}
8: &#39;e&#39;; codepoint: 0x65; encoded bytes: []byte{0x65}
9: &#39;a&#39;; codepoint: 0x61; encoded bytes: []byte{0x61}
10: &#39;n&#39;; codepoint: 0x6e; encoded bytes: []byte{0x6e}
11: &#39;s&#39;; codepoint: 0x73; encoded bytes: []byte{0x73}
12: &#39; &#39;; codepoint: 0x20; encoded bytes: []byte{0x20}
13: &#39;w&#39;; codepoint: 0x77; encoded bytes: []byte{0x77}
14: &#39;o&#39;; codepoint: 0x6f; encoded bytes: []byte{0x6f}
15: &#39;r&#39;; codepoint: 0x72; encoded bytes: []byte{0x72}
16: &#39;l&#39;; codepoint: 0x6c; encoded bytes: []byte{0x6c}
17: &#39;d&#39;; codepoint: 0x64; encoded bytes: []byte{0x64}</code></pre>
<h4 id="map">Map</h4>
<p>user defines a user in the program.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="kw">type</span> user <span class="kw">struct</span> {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>    name <span class="dt">string</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>    username <span class="dt">string</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>}</span></code></pre></div>
<h5 id="declare-and-initialize-2">Declare and initialize</h5>
<p>Declare and make a map that stores values of type user with a key of type string.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>    users1 := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]user)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>    <span class="co">// Add key/value pairs to the map</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a>    users1[<span class="st">&quot;Roy&quot;</span>] = user{<span class="st">&quot;Rob&quot;</span>, <span class="st">&quot;Roy&quot;</span>}</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true"></a>    users1[<span class="st">&quot;Ford&quot;</span>] = user{<span class="st">&quot;Henry&quot;</span>, <span class="st">&quot;Ford&quot;</span>}</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true"></a>    users1[<span class="st">&quot;Mouse&quot;</span>] = user{<span class="st">&quot;Mickey&quot;</span>, <span class="st">&quot;Mouse&quot;</span>}</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true"></a>    users1[<span class="st">&quot;Jackson&quot;</span>] = user{<span class="st">&quot;Michael&quot;</span>, <span class="st">&quot;Jackson&quot;</span>}</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true"></a>    <span class="co">// Iterate over map</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true"></a>    fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Iterate over map</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true"></a>    <span class="kw">for</span> key, value := <span class="kw">range</span> users1 {</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true"></a>            fmt.Println(key, value)</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Iterate over map
Roy {Rob Roy}
Ford {Henry Ford}
Mouse {Mickey Mouse}
Jackson {Michael Jackson}</code></pre>
<h5 id="map-literals">Map literals</h5>
<p>Declare and initialize the map with values.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>users2 := <span class="kw">map</span>[<span class="dt">string</span>]user{</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a>    <span class="st">&quot;Roy&quot;</span>: {<span class="st">&quot;Rob&quot;</span>, <span class="st">&quot;Roy&quot;</span>},</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>    <span class="st">&quot;Ford&quot;</span>: {<span class="st">&quot;Henry&quot;</span>, <span class="st">&quot;Ford&quot;</span>},</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>    <span class="st">&quot;Mouse&quot;</span>: {<span class="st">&quot;Mickey&quot;</span>, <span class="st">&quot;Mouse&quot;</span>},</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>    <span class="st">&quot;Jackson&quot;</span>: {<span class="st">&quot;Michael&quot;</span>, <span class="st">&quot;Jackson&quot;</span>},</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="co">// Iterate over the map.</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Map literals</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a><span class="kw">for</span> key, value := <span class="kw">range</span> users2 {</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>    fmt.Println(key, value)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>=&gt; Map literals
Roy {Rob Roy}
Ford {Henry Ford}
Mouse {Mickey Mouse}
Jackson {Michael Jackson}</code></pre>
<h5 id="delete-key">Delete key</h5>
<div class="sourceCode" id="cb63"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a><span class="bu">delete</span>(users2, <span class="st">&quot;Roy&quot;</span>)</span></code></pre></div>
<h5 id="find-key">Find key</h5>
<p>Find the Roy key. If found is True, we will get a copy value of that type. if found is False, u is still a value of type user but is set to its zero value.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>u1, found1 := users2[<span class="st">&quot;Roy&quot;</span>]</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>u2, found2 := users2[<span class="st">&quot;Ford&quot;</span>]</span></code></pre></div>
<p>Display the value and found flag.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">=&gt; Find key</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>fmt.Println(<span class="st">&quot;Roy&quot;</span>, found1, u1)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>fmt.Println(<span class="st">&quot;Ford&quot;</span>, found2, u2)</span></code></pre></div>
<pre><code>=&gt; Find key
Roy false { }
Ford true {Henry Ford}</code></pre>
<h5 id="map-key-restrictions">Map key restrictions</h5>
<div class="sourceCode" id="cb67"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="kw">type</span> users []user</span></code></pre></div>
<p>Using this syntax, we can define a set of users This is a second way we can define users. We can use an existing type and use it as a base for another type. These are two different types. There is no relationship here. However, when we try use it as a key, like: u := make(map[users]int) the compiler says we cannot use that: “invalid map key type users”</p>
<p>The reason is: whatever we use for the key, the value must be comparable. We have to use it in some sort of boolean expression in order for the map to create a hash value for it.</p>
<h3 id="decoupling">Decoupling</h3>
<h4 id="method">Method</h4>
<h5 id="value-and-pointer-receiver-call">Value and Pointer Receiver Call</h5>
<h5 id="value-and-pointer-semantics">Value and Pointer Semantics</h5>
<h5 id="methods-are-just-functions">Methods are just functions</h5>
<h4 id="interface">Interface</h4>
<h5 id="valueless-type">Valueless type</h5>
<h5 id="interface-via-pointer-receiver">Interface via pointer receiver</h5>
<h5 id="slice-of-interface">Slice of interface</h5>
<h4 id="embedding-55">Embedding 55</h4>
<h5 id="declaring-fields-not-embedding-55">Declaring fields, NOT Embedding 55</h5>
<h5 id="embedding-types-56">Embedding types 56</h5>
<h5 id="embedded-type-and-interface-57">Embedded type and Interface 57</h5>
<h5 id="outer-and-inner-type-implementing-the-same-interface-58">Outer and inner type implementing the same interface 58</h5>
<h4 id="exporting-60">Exporting 60</h4>
<h5 id="guideline-60">Guideline 60</h5>
<h5 id="exported-identifier-60">Exported identifier 60</h5>
<h5 id="accessing-a-value-of-an-unexported-identifier-61">Accessing a value of an unexported identifier 61</h5>
<h5 id="unexported-fields-from-an-exported-struct-62">Unexported fields from an exported struct 62</h5>
<h5 id="exported-types-with-embedded-unexported-types-63">Exported types with embedded unexported types 63</h5>
<h2 id="software-design-65">Software Design 65</h2>
<h3 id="composition-65">Composition 65</h3>
<h4 id="grouping-types-65">Grouping types 65</h4>
<h5 id="grouping-by-state-65">Grouping By State 65</h5>
<h5 id="grouping-by-behavior-67">Grouping By Behavior 67</h5>
<h4 id="decoupling-70">Decoupling 70</h4>
<h5 id="struct-composition-70">Struct Composition 70</h5>
<h5 id="decoupling-with-interface-74">Decoupling With Interface 74</h5>
<h5 id="interface-composition-79">Interface Composition 79</h5>
<h5 id="decoupling-with-interface-composition-84">Decoupling With Interface Composition 84</h5>
<h4 id="conversion">Conversion</h4>
<h5 id="interface-conversions">Interface Conversions</h5>
<p>Mover provides support for moving things.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="kw">type</span> Mover <span class="kw">interface</span> {</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a>  Move()</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Locker provides support for locking and unlocking things.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a><span class="kw">type</span> Locker <span class="kw">interface</span> {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>  Lock()</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>  Unlock()</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>MoveLocker</code> provides support for moving and locking things.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a><span class="kw">type</span> MoveLocker <span class="kw">interface</span> {</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a>  Mover</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a>  Locker</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>bike</code> represents a concrete type for the example.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="kw">type</span> bike <span class="kw">struct</span> {}</span></code></pre></div>
<p><code>Move</code> can change the position of a bike.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="kw">func</span> (bike) Move () {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>  fmt.Println( <span class="st">&quot;Moving the bike&quot;</span> )</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Lock</code> prevents a bike from moving.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="kw">func</span> (bike) Lock () {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>  fmt.Println( <span class="st">&quot;Locking the bike&quot;</span> )</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Unlock</code> allows a bike to be moved.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a><span class="kw">func</span> (bike) Unlock () {</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>  fmt.Println( <span class="st">&quot;Unlocking the bike&quot;</span> )</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>}</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a><span class="kw">func</span> main () {</span></code></pre></div>
<p>Declare variables of the <code>MoveLocker</code> and <code>Mover</code> interfaces set to their zero value.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>  <span class="kw">var</span> ml MoveLocker</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true"></a>  <span class="kw">var</span> m Mover</span></code></pre></div>
<p>Create a value of type <code>bike</code> and assign the value to the <code>MoveLocker</code> interface value.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>  ml = bike{}</span></code></pre></div>
<p>An interface value of type <code>MoveLocker</code> can be implicitly converted into a value of type <code>Mover</code>. They both declare a method named <code>move</code>.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>  m = ml</span></code></pre></div>
<figure>
<img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAFEApIDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAor5m/aw8SeNbPxz8FPDHhLxZceEl8Ua/cWGpXVnFFJIbdbWSRgvmqy7vlO04+9t+Vvu181eJPGPxh8M/C/4866nxc8QTf8Kk8QfYdC8yG2aXUB5kMjf2g3l/vl8uVVVV2dW3bvlVQD66/aQ+N3jj4G+H9Q8Q6F8NLfxp4X0vTZdS1G/k8Qx6fJb+XuZlWJoZGk+Vd24V6X8O/FZ8eeA/DXiVrT7C2tadbal9m8zzPJ86JZNm7au7buC7sV5v+1/dfbP2PvitcbdrTeE759v+9btXY/s9/wDJA/hr/wBi1pv/AKSx0AegUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUVyPjv4meFPhfZ2d34s8Q6d4dtbqVoIZtSuFgjkkEbSMu5v9lWb/AIDXny/tifBVtF03WP8AhZ/hxdP1C6ks7eVrtV3TLt3Ky/eXbvj3M2F+df7y0Ae30UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB4L8dvh34i8ZfF/4G61pGnG703w14gur7VJvNjj+zwtZyRq21mUt8zKvy7q8a8dfs8/EPWfg1+1RoVnoDTat438SSX/h+3+226/boTHaru3NJtj/1cnyybW+Wvt+igD5l/aw/4WX4g+FOvfDzwd8K7zxaniDw3JYyavDrVhZx2dxIrR+W0c0is235W3L8vzV0/wCy/rPj+DwPo3hbxt8Mr3wKdB0eysY7651iyvkvZI41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UAFFFFABXBeMf+SofD3/AH9Q/wDSeu9rgvGP/JUPh7/v6h/6T0Ad7RRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHNah4A8OaxfzX1/otjeXkxXzJp4Fdm2rtX/x2oP+FX+EP+hY0n/wDjrrKKAOT/4Vf4Q/6FjSf/AOOj/hV/hD/oWNJ/8AAOOusooA5P8A4Vf4Q/6FjSf/AADjo/4Vf4Q/6FjSf/AOOusooA5P/hV/hD/oWNJ/8A46P+FX+EP+hY0n/wAA466yigDk/wDhV/hD/oWNJ/8AAOOj/hV/hD/oWNJ/8A466yigDk/+FX+EP+hY0n/wDjo/4Vf4Q/6FjSf/AADjrrKKAOTb4V+EG/5lrS//AAFWug03TbXSbGGzsoVtrWFdsccf3VFXKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDM1zRrfxBo93pt1v+z3UbRyeW21trVyEPwX0OCGONb3WNqrtX/iYyV6FRQBwf/Cm9E/5+9Y/8Gc3/wAVR/wpvRP+fvWP/BnN/wDFV3lFAHB/8Kb0T/n71j/wZzf/ABVH/Cm9E/5+9Y/8Gc3/AMVXeUUAcH/wpvRP+fvWP/BnN/8AFUf8Kb0T/n71j/wZzf8AxVd5RQBwf/Cm9E/5+9Y/8Gc3/wAVR/wpvRP+fvWP/BnN/wDFV3lFAHB/8Kb0T/n71j/wZzf/ABVH/Cm9E/5+9Y/8Gc3/AMVXeUUAcH/wpvRP+fvWP/BnN/8AFVJo/wALNF0bXrHVYpr+a8s/M8v7TdtMo3Ltb73s1dxRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9k=" alt="Implicit conversion of MoveLocker to Mover" /><figcaption aria-hidden="true">Implicit conversion of <code>MoveLocker</code> to <code>Mover</code></figcaption>
</figure>
<p>However, we cannot go in the other direction, like so:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>  ml = m</span></code></pre></div>
<p>The compiler will say:</p>
<pre><code>cannot use m (type Mover) as type MoveLocker in assignment:
Mover does not implement MoveLocker (missing Lock method).</code></pre>
<h5 id="type-assertion">Type assertion</h5>
<p>Interface type <code>Mover</code> does not declare methods named lock and unlock. Therefore, the compiler can’t perform an implicit conversion to assign a value of interface type <code>Mover</code> to an interface value of type <code>MoveLocker</code>. It is irrelevant that the concrete type value of type <code>bike</code> that is stored inside of the <code>Mover</code> interface value implements the <code>MoveLocker</code> interface. We can perform a type assertion at runtime to support the assignment.</p>
<p>Perform a type assertion against the <code>Mover</code> interface value to access a COPY of the concrete type value of type <code>bike</code> that was stored inside of it. Then assign the COPY of the concrete type to the <code>MoveLocker</code> interface. This is the syntax for type assertion. We are taking the interface value itself, dot (bike).We are using bike as a parameter. If <code>m</code> is not <code>nil</code> and there is a <code>bike</code> inside of <code>m</code>, we will get a copy of it since we are using value semantics. Or else, a panic occurs. <code>b</code> is having a copy of <code>bike</code> value.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>    b := m.(bike)</span></code></pre></div>
<p>We can prevent panic when type assertion breaks by destructuring the boolean value that represents type assertion result.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>    b, ok := m.(bike)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a>    fmt.Println(<span class="st">&quot;Does m has value of bike?:&quot;</span>, ok)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a>    ml = b</span></code></pre></div>
<pre><code>Does m has value of bike?: true</code></pre>
<p>It’s important to note that the type assertion syntax provides a way to state what type of value is stored inside the interface. This is more powerful from a language and readability standpoint, than using a casting syntax, like in other languages.</p>
<h5 id="runtime-type-assertion">Runtime Type Assertion</h5>
<div class="sourceCode" id="cb83"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="kw">package</span> main</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a><span class="kw">import</span> (</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true"></a>  <span class="st">&quot;fmt&quot;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true"></a>  <span class="st">&quot;math/rand&quot;</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true"></a>  <span class="st">&quot;time&quot;</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true"></a>)</span></code></pre></div>
<p><code>car</code> represents something you drive.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="kw">type</span> car <span class="kw">struct</span>{}</span></code></pre></div>
<p>String implements the <code>fmt.Stringer</code> interface.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a><span class="kw">func</span> (car) String() <span class="dt">string</span> {</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="st">&quot;Vroom!&quot;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>cloud</code> represents somewhere you store information.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="kw">type</span> cloud <span class="kw">struct</span>{}</span></code></pre></div>
<p>String implements the <code>fmt.Stringer</code> interface.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a><span class="kw">func</span> (cloud) String() <span class="dt">string</span> {</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="st">&quot;Big Data!&quot;</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Seed the number random generator.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>  rand.Seed(time.Now().UnixNano())</span></code></pre></div>
<p>Create a slice of the Stringer interface values.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a>  mvs := []fmt.Stringer{</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true"></a>    car{},</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true"></a>    cloud{},</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Let’s run this experiment ten times.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a>  <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ {</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>    rn := rand.Intn(<span class="dv">2</span>)</span></code></pre></div>
<p>Perform a type assertion that we have a concrete type of cloud in the interface value we randomly chose. This shows us that this checking is at runtime, not compile time.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a>    <span class="kw">if</span> v, ok := mvs[rn].(cloud); ok {</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a>      fmt.Println(<span class="st">&quot;Got Lucky:&quot;</span>, v)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true"></a>      <span class="kw">continue</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true"></a>    }</span></code></pre></div>
<p>We have to guarantee that the variable in question (<code>x</code> in <code>x.(T)</code>) can always be asserted correctly as T type Or else, We wouldn’t want to use that <code>ok</code> variable because we want it to panic if there is an integrity issue. We must shut it down immediately if that happens if we cannot recover from a panic and guarantee that we are back at 100% integrity, the software has to be restarted.</p>
<p>Shutting down means you have to call <code>log.Fatal</code>, <code>os.exit</code>, or <code>panic</code> for stack trace. When we use type assertion, we need to understand when it is okay that whatever we are asking for is not there.</p>
<p>If the type assertion is causing us to call the concrete value out, that should raise a big flag. We are using interface to maintain a level of decoupling and now we are using type assertion to go back to the concrete.</p>
<p>When we are in the concrete, we are putting our codes in the situation where cascading changes can cause widespread refactoring. What we want with interface is the opposite, internal changes minimize cascading changes.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a>    fmt.Println(<span class="st">&quot;Got Unlucky&quot;</span>)</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>  }</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Got Unlucky
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Unlucky</code></pre>
<h4 id="interface-pollution">Interface Pollution</h4>
<p>It comes from the fact that people are designing software from the interface first down instead of concrete type up. So, why are we using an interface here?</p>
<p><strong>Myth #1:</strong> We are using interfaces because we have to use interfaces.</p>
<p>Answer: No. We don’t have to use interfaces. We use it when it is practical and reasonable to do so.</p>
<p>Even though they are wonderful, there is a cost of using interfaces: a level of indirection and potential allocation when we store concrete type inside of them. Unless the cost of that is worth whatever decoupling we are getting, we shouldn’t be using interfaces.</p>
<p><strong>Myth #2:</strong>  We need to be able to test our code so we need to use interfaces.</p>
<p>Answer: No. We must design our API that is usable for user application developer first, not our test.</p>
<p>Below is an example that creates interface pollution by improperly using an interface when one is not needed.</p>
<p>Server defines a contract for TCP servers. This is a little bit of a smell because this is some sort of APIs that is going to be exposed to users and already that is a lot of behaviors brought in a generic interface.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a>type Server interface {</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>  Start() <span class="dt">error</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>  Stop() <span class="dt">error</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>  Wait() <span class="dt">error</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>server</code> is our Server implementation. They match the name. However, that is not necessarily bad.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a>type server struct {</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a>  host <span class="dt">string</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>NewServer</code> returns an interface value of type Server with a server implementation. Here is the factory function. It immediately starts to smell even worse. It is returning the interface value.</p>
<p>It is not that functions and interfaces cannot return interface values. They can. But normally, that should raise a flag. The concrete type is the data that has the behavior and the interface normally should be used as accepting the input to the data, not necessarily going out.</p>
<p>SMELL - Storing an unexported type pointer in the interface.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a><span class="kw">func</span> NewServer(host <span class="dt">string</span>) Server {</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a>  <span class="kw">return</span> &amp;server{host}</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Start allows the server to begin to accept requests. From now, let’s pretend there is a specific implementation for each of these methods.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a><span class="kw">func</span> (s *server) Start() error {</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Stop shuts the server down.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a><span class="kw">func</span> (s *server) Stop() <span class="dt">error</span> {</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Wait prevents the server from accepting new connections.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true"></a><span class="kw">func</span> (s *server) Wait() error {</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb100"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span></code></pre></div>
<p>Create a new <code>Server</code>.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true"></a>  srv := NewServer(<span class="st">&quot;localhost&quot;</span>)</span></code></pre></div>
<p>Use the API.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>  srv.Start()</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a>  srv.Stop()</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a>  srv.Wait()</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>This code here couldn’t care less nor would it change if <code>srv</code> was the concrete type, not the interface. The interface is not providing any level of support whatsoever. There is no decoupling here that is happening. It is not giving us anything special here. All is doing is causing us another level of indirection.</p>
<p>It smells because:</p>
<ul>
<li>The package declares an interface that matches the entire API of its own concrete type.</li>
<li>The interface is exported but the concrete type is unexported.</li>
<li>The factory function returns the interface value with the unexported concrete type value inside.</li>
<li>The interface can be removed and nothing changes for the user of the API.</li>
<li>The interface is not decoupling the API from change.</li>
</ul>
<h5 id="remove-interface-pollution">Remove Interface Pollution</h5>
<p>We’re going to remove the improper interface usage from the previous program.</p>
<p><code>Server</code> implementation.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true"></a>type Server <span class="kw">struct</span> {</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true"></a>  host <span class="dt">string</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>NewServer</code> returns just a concrete pointer of type <code>Server</code></p>
<div class="sourceCode" id="cb104"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a><span class="kw">func</span> NewServer(host <span class="dt">string</span>) *Server {</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>  return &amp;Server{host}</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Start</code> allows the server to begin to accept requests.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true"></a><span class="kw">func</span> (s *Server) Start() <span class="dt">error</span> {         </span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Stop</code> shuts the server down.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>func (s *Server) Stop() <span class="dt">error</span> {</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Wait</code> prevents the server from accepting new connections.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true"></a><span class="kw">func</span> (s *Server) Wait() <span class="dt">error</span> {</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Create a new <code>Server</code>.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>  srv := NewServer(<span class="st">&quot;localhost&quot;</span>)</span></code></pre></div>
<p>Use the APIs.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true"></a>  srv.Start()</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true"></a>  srv.Stop()</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true"></a>  srv.Wait()</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Guidelines around interface pollution:</strong></p>
<p>Use an interface:</p>
<ul>
<li>When users of the API need to provide an implementation detail.</li>
<li>When APIs have multiple implementations that need to be maintained.</li>
<li>When parts of the APIs that can change have been identified and require decoupling.</li>
</ul>
<p>Question an interface:</p>
<ul>
<li>When its only purpose is for writing testable APIs (write usable APIs first).</li>
<li>When it’s not providing support for the API to decouple from change.</li>
<li>When it’s not clear how the interface makes the code better.</li>
</ul>
<h4 id="mocking">Mocking</h4>
<h5 id="package-to-mock">Package To Mock</h5>
<p>It is important to mock things. Most things over the network can be mocked in our test. However, mocking our database is a different story because it is too complex. This is where Docker can come in and simplify our code by allowing us to launch our database while running our tests and have that clean database for everything we do.</p>
<p>Every API only needs to focus on its test. We no longer have to worry about the application user or user over API test. We used to worry about: if we don’t have that interface, the user who uses our API can’t write tests. That is gone. The example below will demonstrate the reason.</p>
<p>Imagine we are working at a company that decides to incorporate Go as a part of its stack. They have their internal pubsub system that all applications are supposed to use. Maybe they are doing event sourcing and there is a single pubsub platform they are using that is not going to be replaced. They need the pubsub API for Go that they can start building services that connect into this event source.</p>
<p>So what can change? Can the event source change?</p>
<p>If the answer is no, then it immediately tells us that we don’t need to use interfaces. We can build the entire API in the concrete, which we would do first anyway. We then write tests to make sure everything works.</p>
<p>A couple days later, they come to us with a problem. They have to write tests and they cannot hit the pubsub system directly when my test runs so they need to mock that out. They want us to give them an interface. However, we don’t need an interface because our API doesn’t need an interface. They need an interface, not us. They need to decouple from the pubsub system, not us.</p>
<p>They can do any decoupling they want because this is Go. The next file will be an example of their application. Package pubsub simulates a package that provides publication/subscription type services.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a><span class="kw">package</span>  main</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a><span class="kw">import</span>  (</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a>  <span class="st">&quot;fmt&quot;</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true"></a>)</span></code></pre></div>
<p><code>PubSub</code> provides access to a queue system.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true"></a><span class="kw">type</span> PubSub struct {</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true"></a>  host <span class="dt">string</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>New creates a pubsub value for use.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a><span class="kw">func</span> New(host <span class="dt">string</span>) *PubSub {</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a>  ps := PubSub{</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a>    host: host,</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>  }</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a>  <span class="kw">return</span>  &amp;ps</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Publish sends the data to the specified key.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true"></a><span class="kw">func</span> (ps *PubSub) Publish(key <span class="dt">string</span>, v <span class="kw">interface</span>{}) <span class="dt">error</span> {</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true"></a>  fmt.Println(<span class="st">&quot;Actual PubSub: Publish&quot;</span>)</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true"></a>  return   <span class="ot">nil</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Subscribe sets up a request to receive messages from the specified key.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a><span class="kw">func</span> (ps *PubSub) Subscribe(key <span class="dt">string</span>) <span class="dt">error</span> {</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a>  fmt.Println(<span class="st">&quot;Actual PubSub: Subscribe&quot;</span>)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true"></a>  return <span class="ot">nil</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true"></a>}</span></code></pre></div>
<h5 id="client">Client</h5>
<p>Sample program to show how we can personally mock concrete types when we need to for our own packages or tests.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true"></a><span class="kw">package</span>  main</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true"></a><span class="kw">import</span>  (</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true"></a>  <span class="st">&quot;fmt&quot;</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true"></a>)</span></code></pre></div>
<p><code>publisher</code> is an interface to allow this package to mock the pubsub package. When we are writing our applications, declare our own interface that maps out all the APIs calls we need for the APIs. The concrete types APIs in the previous files satisfy it out of the box. We can write the entire application with mocking decoupling from concrete implementations.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a><span class="kw">type</span> publisher <span class="kw">interface</span> {</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true"></a>  Publish(key <span class="dt">string</span>, v <span class="kw">interface</span>{}) <span class="dt">error</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true"></a>  Subscribe(key <span class="dt">string</span>) <span class="dt">error</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>mock</code> is a concrete type to help support the mocking of the pubsub package.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true"></a><span class="kw">type</span> mock <span class="kw">struct</span>{}</span></code></pre></div>
<p><code>Publish</code> implements the <code>publisher</code> interface for the mock.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a><span class="kw">func</span> (m *mock) Publish(key <span class="dt">string</span>, v <span class="kw">interface</span>{}) <span class="dt">error</span> {</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a>  <span class="co">// ADD YOUR MOCK FOR THE PUBLISH CALL.</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true"></a>  fmt.Println(<span class="st">&quot;Mock PubSub: Publish&quot;</span>)</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true"></a>  return <span class="ot">nil</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>Subscribe</code> implements the <code>publisher</code> interface for the mock.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true"></a><span class="kw">func</span>  (m *mock) Subscribe(key <span class="dt">string</span>) <span class="dt">error</span> {</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true"></a>  <span class="co">// ADD YOUR MOCK FOR THE SUBSCRIBE CALL.</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true"></a>  fmt.Println(<span class="st">&quot;Mock PubSub: Subscribe&quot;</span>)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true"></a>  return <span class="ot">nil</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>Create a slice of <code>publisher</code> interface values. Assign the address of a pubsub. <code>PubSub</code> value and the address of a mock value.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a><span class="kw">func</span> main() {</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true"></a>  pubs := []publisher{</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true"></a>    New(<span class="st">&quot;localhost&quot;</span>),</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true"></a>    &amp;mock{},</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Range over the interface value to see how the publisher interface provides the level of decoupling the user needs. The <code>pubsub</code> package did not need to provide the interface type.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true"></a>  <span class="kw">for</span> _, p := <span class="kw">range</span> pubs {</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true"></a>    p.Publish(<span class="st">&quot;key&quot;</span>, <span class="st">&quot;value&quot;</span>)</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true"></a>    p.Subscribe(<span class="st">&quot;key&quot;</span>)</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true"></a>  }</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="error-handling">Error Handling</h3>
<h4 id="default-error-values">Default error values</h4>
<p>Integrity matters. Nothing trumps integrity. Therefore, part of integrity is error handling. It is a big part of what we do everyday. It has to be a part of the main code. First, let’s look at the language mechanic first on how the default error type is implemented.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a>package​ main</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a>import​ ​<span class="st">&quot;fmt&quot;</span></span></code></pre></div>
<p>http://golang.org/pkg/builtin/#error</p>
<p>This is pre-included in the language so it looks like an unexported type. It has one active behavior, which is Error returned a string. Error handling is decoupled because we are always working with error interface when we are testing our code.</p>
<p>Errors in Go are really just values. We are going to valuate these through the decoupling of the interface. Decoupling error handling means that cascading changes will bubble up through the user application, causes cascading wide effect through the code base. It’s important that we leverage the interface here as much as we can.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true"></a>type​ <span class="dt">error</span> ​interface​ {</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true"></a>    Error() ​string</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>http://golang.org/src/pkg/errors/errors.go</p>
<p>This is the default concrete type that comes from the error package. It is an unexported type that has an unexported field. This gives us enough context to make us form a decision.</p>
<p>We have responsibility around error handling to give the caller enough context to make them form a decision so they know how to handle this situation.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a>type​ errorString ​struct​ {</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a>    s ​string</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>http://golang.org/src/pkg/errors/errors.go</p>
<p>This is using a pointer receiver and returning a string. If the caller must call this method and parse a string to see what is going on then we fail.</p>
<p>This method is only for logging information about the error.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true"></a>func​ (e *errorString) ​Error​() ​string​ {</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true"></a>    return​ e.s</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>http://golang.org/src/pkg/errors/errors.go</p>
<p>New returns an error interface that formats as the given text. When we call New, what we are doing is creating errorString value, putting some sort of string in there.. Since we are returning the address of a concrete type, the user will get an error interface value where the first word is a *errorString and the second word points to the original value. We are going to stay decoupled during the error handling.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a>func​ ​New​(text ​string​) ​error​ {</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true"></a>    return​ &amp;errorString{text}</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is a very traditional way of error handling in Go. We are calling webCall and returning the error interface and storing that in a variable.</p>
<p>nil is a special value in Go. What “error != nil” actually means is that we are asking if there is a concrete type value that is stored in error type interface. Because if error is not nil, there is a concrete value stored inside. If it is the case, we’ve got an error.</p>
<p>Now do we handle the error, do we return the error up the call stack for someone else to handle? We will talk about this later.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true"></a>func​ ​main​() {</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true"></a>    if​ err := webCall(); err != ​nil​ {</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true"></a>        fmt.Println(err)</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true"></a>        <span class="kw">return</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true"></a>    }</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true"></a>    fmt.Println(​<span class="st">&quot;Life is good&quot;</span>​)</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>webCall performs a web operation.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true"></a>func​ ​webCall​() ​error​ {</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true"></a>    return​ New(​<span class="st">&quot;Bad Request&quot;</span>​)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true"></a>}</span></code></pre></div>
<h4 id="error-variables">Error variables</h4>
<p>Let’s use error variables to determine the exact error being returned.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true"></a>package​ main</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true"></a>import​ (</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true"></a>    <span class="st">&quot;errors&quot;</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true"></a>)</span></code></pre></div>
<p>We want these to be on the top of the source code file. Naming convention: starting with Err. They have to be exported because our users need to access them.</p>
<p>These are all error interfaces that we have discussed in the last file, with variables tied to them. The contexts for these errors are the variables themselves. This allows us to continue using the default error type, that unexported type with unexported field to maintain a level of decoupling through error handling.</p>
<p>ErrBadRequest is returned when there are problems with the request. ErrPageMoved is returned when a 301/302 is returned.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true"></a>var​ (</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true"></a>    ErrBadRequest = errors.New(​<span class="st">&quot;Bad Request&quot;</span>​)</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true"></a>    ErrPageMoved = errors.New(​<span class="st">&quot;Page Moved&quot;</span>​)</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true"></a>)</span></code></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true"></a>func​ ​main​() {</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true"></a>    if​ err := webCall(​true​); err != ​nil​ {</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true"></a>        switch​ err {</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true"></a>        case​ ErrBadRequest:</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true"></a>            fmt.Println(​<span class="st">&quot;Bad Request Occurred&quot;</span>​)</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true"></a>            <span class="kw">return</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true"></a>        case​ ErrPageMoved:</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true"></a>            fmt.Println(​<span class="st">&quot;The Page moved&quot;</span>​)</span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true"></a>            <span class="kw">return</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true"></a>        default​:</span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true"></a>            fmt.Println(err)</span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true"></a>            <span class="kw">return</span></span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true"></a>        }</span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true"></a>    }</span>
<span id="cb131-15"><a href="#cb131-15" aria-hidden="true"></a>    fmt.Println(​<span class="st">&quot;Life is good&quot;</span>​)</span>
<span id="cb131-16"><a href="#cb131-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>webCall performs a web operation.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true"></a>func​ ​webCall​(b ​bool​) ​error​ {</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true"></a>    if​ b {</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true"></a>        return​ ErrBadRequest</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true"></a>    }</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true"></a>    return​ ErrPageMoved</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Bad Request Occurred</code></pre>
<h4 id="type-as-context">Type as context</h4>
<p>It is not always possible to be able to say the interface value itself will be enough context. Sometimes, it requires more context. For example, a networking problem can be really complicated. Error variables wouldn’t work there. Only when the error variables wouldn’t work, we should go ahead and start working with a custom concrete type for the error.</p>
<p>Below are two custom error types from the JSON package in the standard library and how we can use those. This is type as context.</p>
<p>http://golang.org/src/pkg/encoding/json/decode.go</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true"></a><span class="kw">package</span> main</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true"></a>import​ (</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true"></a>    <span class="st">&quot;reflect&quot;</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true"></a>)</span></code></pre></div>
<p>An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type. Naming convention: The word “Error” ends at the name of the type.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true"></a>type​ UnmarshalTypeError ​struct​ {</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true"></a>    Value ​string​ ​<span class="co">// description of JSON value</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true"></a>    Type reflect.Type ​<span class="co">// type of Go value it could not be assigned to</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>UnmarshalTypeError implements the error interface. We are using pointer semantics. In the implementation, we are validating all the fields being used in the error message. If not, we have a problem. Because why would you add a field to the custom error type and not displaying it on your log when this method would call. We only do this when we really need it.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true"></a>func​ (e *UnmarshalTypeError) ​Error​() ​string​ {</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true"></a>    return​ ​<span class="st">&quot;json: cannot unmarshal &quot;</span>​ + e.Value + ​<span class="st">&quot; into Go value of type &quot;</span>​ + e.Type.String()</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. The argument to Unmarshal must be a non-nil pointer. This concrete type is used when we don’t pass the address of a value into the Unmarshal function.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true"></a>type​ InvalidUnmarshalError ​struct​ {</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true"></a>    Type reflect.Type</span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>InvalidUnmarshalError implements the error interface.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true"></a>func​ (e *InvalidUnmarshalError) ​Error​() ​string​ {</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true"></a>    if​ e.Type == ​nil​ {</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true"></a>        return​ ​<span class="st">&quot;json: Unmarshal(nil)&quot;</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true"></a>    }</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true"></a>    if​ e.Type.Kind() != reflect.Ptr {</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true"></a>        return​ ​<span class="st">&quot;json: Unmarshal(non-pointer &quot;</span>​ + e.Type.String() + <span class="st">&quot;)&quot;</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true"></a>    }</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true"></a>    return​ ​<span class="st">&quot;json: Unmarshal(nil &quot;</span>​ + e.Type.String() + ​<span class="st">&quot;)&quot;</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>user is a type for use in the Unmarshal call.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true"></a>type​ user ​struct​ {</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true"></a>    Name ​int</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb140"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true"></a>func​ ​main​() {</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true"></a>    var​ u user</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true"></a>    err := Unmarshal([]​byte​(​<span class="st">`{&quot;name&quot;:&quot;bill&quot;}`</span>​), u) ​<span class="co">// Run with a value and pointer.</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true"></a>    if​ err != ​nil​ {</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true"></a>        This is a special ​type​ assertion that only works on the ​switch​.</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true"></a>​        switch​ e := err.(​type​) {</span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true"></a>        case​ *UnmarshalTypeError:</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true"></a>            fmt.Printf(​<span class="st">&quot;UnmarshalTypeError: Value[%s] Type[%v]</span><span class="ch">\n</span><span class="st">&quot;</span>​, e.Value, e.Type)</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true"></a>        case​ *InvalidUnmarshalError:</span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true"></a>            fmt.Printf(​<span class="st">&quot;InvalidUnmarshalError: Type[%v]</span><span class="ch">\n</span><span class="st">&quot;</span>​, e.Type)</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true"></a>        default​:</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true"></a>            fmt.Println(err)</span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true"></a>        }</span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true"></a>        <span class="kw">return</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true"></a>    }</span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true"></a>    fmt.Println(​<span class="st">&quot;Name:&quot;</span>​, u.Name)</span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>Unmarshal simulates an unmarshal call that always fails. Notice the parameters here: The first one is a slice of byte and the second one is an empty interface. The empty interface basically says nothing, which means any value can be passed into this function. We are going to reflect on the concrete type that is stored inside this interface and we are going to validate that it is a pointer or not nil. We then return different error types depending on these.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true"></a>func​ ​Unmarshal​(data []​byte​, v ​interface​{}) ​error​ {</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true"></a>    rv := reflect.ValueOf(v)</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true"></a>    if​ rv.Kind() != reflect.Ptr || rv.IsNil() {</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true"></a>        return​ &amp;InvalidUnmarshalError{reflect.TypeOf(v)}</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true"></a>    }</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true"></a>    return​ &amp;UnmarshalTypeError{​<span class="st">&quot;string&quot;</span>​, reflect.TypeOf(v)}</span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>There is one flaw when using type as context here. In this case, we are now going back to the concrete. We walk away from the decoupling because our code is now bound to these concrete types. If the developer who wrote the json package makes any changes to these concrete types, that’s gonna create a cascading effect all the way through our code. We are no longer protected by the decoupling of the error interface.</p>
<p>This sometimes has to happen. Can we do something different not to lose the decoupling. This is where the idea of behavior as context comes in.</p>
<h4 id="behavior-as-context">Behavior as context</h4>
<p>Behavior as context allows us to use a custom error type as our context but avoid that type assertion back to the concrete. We get to maintain a level of decoupling in our code.</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true"></a>package​ main</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true"></a>import​ (</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true"></a>    <span class="st">&quot;bufio&quot;</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true"></a>    <span class="st">&quot;io&quot;</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true"></a>    <span class="st">&quot;log&quot;</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true"></a>    <span class="st">&quot;net&quot;</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true"></a>)</span></code></pre></div>
<p>client represents a single connection in the room.</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true"></a>type​ client ​struct​ {</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true"></a>    name ​string</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true"></a>    reader *bufio.Reader</span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>TypeAsContext shows how to check multiple types of possible custom error types that can be returned from the net package.</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true"></a>func​ (c *client) ​TypeAsContext​() {</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true"></a>    for​ {</span></code></pre></div>
<p>We are using reader interface value to decouple ourselves from the network read.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true"></a>        line, err := c.reader.ReadString(​<span class="ch">&#39;\n&#39;</span>​)</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true"></a>        if​ err != ​nil​ {</span></code></pre></div>
<p>This is using type as context like the previous example. What special here is the method named Temporary. If it is, we can keep going but if not, we have to break things down and build things back up. Every one of these cases care only about 1 thing: the behavior of Temporary. This is what important. We can switch here, from type as context to type as behavior if we do this type assertion and only ask about the potential behavior of that concrete type itself. We can go ahead and declare our own interface called temporary like below.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true"></a>            switch​ e := err.(​type​) {</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true"></a>            case​ *net.OpError:</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true"></a>                if​ !e.Temporary() {</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;Temporary: Client leaving chat&quot;</span>​)</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true"></a>                }</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true"></a>            case​ *net.AddrError:</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true"></a>                if​ !e.Temporary() {</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;Temporary: Client leaving chat&quot;</span>​)</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true"></a>                }</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true"></a>            case​ *net.DNSConfigError:</span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true"></a>                if​ !e.Temporary() {</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;Temporary: Client leaving return chat&quot;</span>)</span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true"></a>                }</span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true"></a>            default​:</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true"></a>                if​ err == io.EOF {</span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;EOF: Client leaving chat&quot;</span>​)</span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true"></a>                }</span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true"></a>            log.Println(​<span class="st">&quot;read-routine&quot;</span>​, err)</span>
<span id="cb146-23"><a href="#cb146-23" aria-hidden="true"></a>            }</span>
<span id="cb146-24"><a href="#cb146-24" aria-hidden="true"></a>        }</span>
<span id="cb146-25"><a href="#cb146-25" aria-hidden="true"></a>    fmt.Println(line)</span>
<span id="cb146-26"><a href="#cb146-26" aria-hidden="true"></a>    }</span>
<span id="cb146-27"><a href="#cb146-27" aria-hidden="true"></a>}</span></code></pre></div>
<p>temporary is declared to test for the existence of the method coming from the net package. Because Temporary is the only behavior we care about. If the concrete type has the method named temporary then this is what we want. We get to stay decoupled and continue to work at the interface level.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true"></a>type​ temporary ​interface​ {</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true"></a>    Temporary() ​bool</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>BehaviorAsContext shows how to check for the behavior of an interface that can be returned from the net package.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true"></a>func​ (c *client) ​BehaviorAsContext​() {</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true"></a>    for​ {</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true"></a>        line, err := c.reader.ReadString(​<span class="ch">&#39;\n&#39;</span>​)</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true"></a>        if​ err != ​nil​ {</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true"></a>            switch​ e := err.(​type​) {</span></code></pre></div>
<p>We can reduce 3 cases into 1 by asking in the case here during type assertion: Does the concrete type stored inside the error interface also implement this interface. We can declare and leverage that interface ourselves.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true"></a>            case​ temporary:</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true"></a>                if​ !e.Temporary() {</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;Temporary: Client leaving return chat&quot;</span>)</span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true"></a>                }</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true"></a>            default​:</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true"></a>                if​ err == io.EOF {</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true"></a>                    log.Println(​<span class="st">&quot;EOF: Client leaving chat&quot;</span>​)</span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true"></a>                    <span class="kw">return</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true"></a>                }</span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true"></a>                log.Println(​<span class="st">&quot;read-routine&quot;</span>​, err)</span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true"></a>            }</span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true"></a>        }</span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true"></a>        fmt.Println(line)</span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true"></a>    }</span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true"></a>}</span></code></pre></div>
<p><strong>Lesson:</strong></p>
<p>Thank to Go Implicit Conversion. We can maintain a level of decoupling by creating an interface with methods or behaviors that we only want, and use it instead of concrete type for type assertion switch.</p>
<h4 id="finding-the-bug">Finding the bug</h4>
<div class="sourceCode" id="cb150"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true"></a>package​ main</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true"></a>import​ ​<span class="st">&quot;log&quot;</span></span></code></pre></div>
<p>customError is just an empty struct.</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true"></a>type​ customError ​struct​{}</span></code></pre></div>
<p>Error implements the error interface.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true"></a>func​ (c *customError) ​Error​() ​string​ {</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true"></a>    return​ ​<span class="st">&quot;Find the bug.&quot;</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>fail returns nil values for both return types.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true"></a>func​ ​fail​() ([]​byte​, *customError) {</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true"></a>    return​ ​nil​, ​nil</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb154"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true"></a>func​ ​main​() {</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true"></a>    var​ err <span class="dt">error</span></span></code></pre></div>
<p>When we call fail, it returns the value of nil. However, we have the nil value of type *customError. We always want to use the error interface as the return value. The customError type is just an artifact, a value that we store inside. We cannot use the custom type directly. We must use the error interface, like so func fail() ([]byte, error)</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true"></a>    if​ _, err = fail(); err != ​nil​ {</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true"></a>        log.Fatal(​<span class="st">&quot;Why did this fail?&quot;</span>​)</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true"></a>    }</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true"></a>    log.Println(​<span class="st">&quot;No Error&quot;</span>​)</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true"></a>}</span></code></pre></div>
<h4 id="wrapping-errors">Wrapping Errors</h4>
<p>Error handling has to be part of our code and usually it is bound to logging. The main goal of logging is to debug. We only log things that are actionable. Only log the contexts that are allowed us to identify what is going on. Anything else ideally is noise and would be better suited up on the dashboard through metrics. For example, socket connection and disconnection, we can log these but these are not actionable because we don’t necessarily lookup the log for that.</p>
<p>There is a package that is written by Dave Cheney called errors that let us simplify error handling and logging at the same time. Below is a demonstration on how to leverage the package to simplify our code. By reducing logging, we also reduce a large amount of pressure on the heap (garbage collection).</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true"></a><span class="kw">import</span> (</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true"></a>    <span class="st">&quot;github.com/pkg/errors&quot;</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true"></a>)</span></code></pre></div>
<p>AppError represents a custom error type.</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true"></a>type​ AppError ​struct​ {</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true"></a>    State ​int</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>AppError implements the error interface.</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true"></a>func​ (c *AppError) ​Error​() ​string​ {</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true"></a>    return​ fmt.Sprintf(​<span class="st">&quot;App Error, State: %d&quot;</span>​, c.State)</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb159"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true"></a>func​ ​main​() {</span></code></pre></div>
<p>Make the function call and validate the error. firstCall calls secondCall calls thirdCall then results in AppError. Start down the call stack, in thirdCall, where the error occurs. This is the root of the error. We return it up the call stack in our traditional error interface value.</p>
<p>Back to secondCall, we get the interface value and there is a concrete type stored inside the value. secondCall has to make a decision whether to handle the error and push up the call stack if it cannot handle. If secondCall decides to handle the error, it has the responsibility of logging it. If not, its responsibility is to move it up. However, if we are going to push it up the call stack, we cannot lose context. This is where the error package comes in. We create a new interface value that wraps this error, add a context around it and push it up. This maintains the call stack of where we are in the code.</p>
<p>Similarly, firstCall doesn’t handle the error but wraps and pushes it up. In main, we are handling the call, which means the error stops here and we have to log it.</p>
<p>In order to properly handle this error, we need to know that the root cause of this error was. It is the original error that is not wrapped. Cause method will bubble up this error out of these wrapping and allow us to be able to use all the language mechanics we have.</p>
<p>We are not only able to access the State even though we’ve done this assertion back to concrete, we can log out the entire stack trace by using %+v for this call.</p>
<p>Use type as context to determine cause. We got our custom error type.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true"></a>    if​ err := firstCall(​10​); err != ​nil​ {</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true"></a>        switch​ v := errors.Cause(err).(​type​) {</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true"></a>        case​ *AppError:</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true"></a>            fmt.Println(​<span class="st">&quot;Custom App Error:&quot;</span>​, v.State)</span></code></pre></div>
<p>Display the stack trace for the error.</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true"></a>            fmt.Println(​<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Stack Trace</span><span class="ch">\n</span><span class="st">********************************&quot;</span>​)</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true"></a>            fmt.Printf(​<span class="st">&quot;%+v</span><span class="ch">\n</span><span class="st">&quot;</span>​, err)</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true"></a>            fmt.Println(​<span class="st">&quot;</span><span class="ch">\n</span><span class="st">No Trace</span><span class="ch">\n</span><span class="st">********************************&quot;</span>​)</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true"></a>            fmt.Printf(​<span class="st">&quot;%v</span><span class="ch">\n</span><span class="st">&quot;</span>​, err)</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true"></a>        }</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true"></a>    }</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>firstCall makes a call to a secondCall function and wraps any error.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true"></a>func​ ​firstCall​(i ​int​) ​error​ {</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true"></a>    if​ err := secondCall(i); err != ​nil​ {</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true"></a>        return​ errors.Wrapf(err, ​<span class="st">&quot;firstCall-&gt;secondCall(%d)&quot;</span>​, i)</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true"></a>    }</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true"></a>    return​ ​nil</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>secondCall makes a call to a thirdCall function and wraps any error.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true"></a>func​ ​secondCall​(i ​int​) ​error​ {</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true"></a>    if​ err := thirdCall(); err != ​nil​ {</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true"></a>        return​ errors.Wrap(err, ​<span class="st">&quot;secondCall-&gt;thirdCall()&quot;</span>​)</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true"></a>    }</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true"></a>    return​ ​nil</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>thirdCall function creates an error value we will validate.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true"></a>func​ ​thirdCall​() ​error​ {</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true"></a>    return​ &amp;AppError{​99​}</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Custom App Error: 99
Stack Trace
********************************
App Error, State: 99
secondCall-&gt;thirdCall()
main.secondCall
    /tmp/sandbox880380539/prog.go:74
main.firstCall
    /tmp/sandbox880380539/prog.go:65
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373
firstCall-&gt;secondCall(10)
main.firstCall
    /tmp/sandbox880380539/prog.go:66
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373

No Trace
********************************
firstCall-&gt;secondCall(10): secondCall-&gt;thirdCall(): App Error, State: 99</code></pre>
<h2 id="concurrency-114">Concurrency 114</h2>
<h3 id="mechanics-114">Mechanics 114</h3>
<h4 id="goroutine-114">Goroutine 114</h4>
<h4 id="language-mechanics-121">Language Mechanics 121</h4>
<h5 id="sequence-123">Sequence 123</h5>
<h5 id="goroutine-time-slicing-124">Goroutine time slicing 124</h5>
<h5 id="goroutines-and-parallelism-126">Goroutines and parallelism 126</h5>
<h4 id="data-race-128">Data race 128</h4>
<h5 id="race-detection-128">Race Detection 128</h5>
<h5 id="atomic-functions-131">Atomic Functions 131</h5>
<h5 id="mutexes-133">Mutexes 133</h5>
<h5 id="readwrite-mutex-135">Read/Write Mutex 135</h5>
<h4 id="channel-139">Channel 139</h4>
<h5 id="language-mechanics-139">Language Mechanics 139</h5>
<h5 id="unbuffered-channel-signaling-with-data-141">Unbuffered channel: Signaling with data 141</h5>
<h5 id="unbuffered-channel-double-signal-143">Unbuffered channel: Double signal 143</h5>
<h5 id="unbuffered-channel-select-and-receive-144">Unbuffered channel: select and receive 144</h5>
<h5 id="unbuffered-channel-select-and-send-145">Unbuffered channel: select and send 145</h5>
<h5 id="buffered-channel-select-and-drop-146">Buffered channel: Select and drop 146</h5>
<h5 id="unbuffered-channel-tennis-match-148">Unbuffered channel (Tennis match) 148</h5>
<h5 id="unbuffered-channel-replay-race-150">Unbuffered channel (Replay race) 150</h5>
<h5 id="buffered-channel-fan-out-153">Buffered channel: Fan Out 153</h5>
<h5 id="select-157">Select 157</h5>
<h3 id="patterns-164">Patterns 164</h3>
<h4 id="context-164">Context 164</h4>
<h5 id="store-and-retrieve-values-from-a-context-164">Store and retrieve values from a context 164</h5>
<h5 id="withcancel-166">WithCancel 166</h5>
<h5 id="withdeadline-168">WithDeadline 168</h5>
<h5 id="withtimeout-169">WithTimeout 169</h5>
<h5 id="requestresponse-171">Request/Response 171</h5>
<h2 id="testing-and-profiling-173">Testing and Profiling 173</h2>
<h3 id="testing-173">Testing 173</h3>
<h4 id="basic-unit-test-173">Basic Unit Test 173</h4>
<h5 id="table-test-176">Table Test 176</h5>
<h5 id="sub-test-177">Sub Test 177</h5>
<h5 id="web-server-181">Web Server 181</h5>
<h5 id="mock-server-187">Mock Server 187</h5>
<h3 id="benchmarking-191">Benchmarking 191</h3>
<h4 id="basic-benchmark-191">Basic Benchmark 191</h4>
<h4 id="sub-benchmark-192">Sub Benchmark 192</h4>
<h3 id="profiling-193">Profiling 193</h3>
<h4 id="stack-trace-193">Stack Trace 193</h4>
<h5 id="review-stack-trace-193">Review Stack Trace 193</h5>
<h5 id="packing-195">Packing 195</h5>
<h4 id="godebug-196">GODEBUG 196</h4>
<h5 id="memory-tracing-196">Memory Tracing 196</h5>
<h2 id="keep-in-touch-199">Keep in touch 199</h2>
</body>
</html>
